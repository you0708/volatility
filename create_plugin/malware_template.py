import volatility.win32.tasks as tasks
import volatility.utils as utils
import volatility.debug as debug
import volatility.plugins.common as common
import volatility.plugins.malware.malfind as malfind

import struct, re, json
try:
    import yara
except ImportError:
    debug.error("This plugin requires yara module.")

HR = '-'*80
MAX_SCAN_SIZE = 0x200000
SIGNATURES = {
    'namespace1': 'rule Malware_Name { \
                    strings: \
                       $s = "TEST" \
                    condition: $s }'
}

MALWARE_NAME_INFO = [{
    'version': 'test',
    'pattern': '\x90\x90\x90\x90',
    'cfg_offset': 0x10,
    'cfg_size': 0x100,
    'cfg_info': [['C2', 0], ['ID', 0x100]] # [name, offset]
}]

def snake_case(s):
    return re.compile(r' ').sub(r'_', s).lower()

def is_valid_profile(profile):
    return (profile.metadata.get('os', 'unknown') == 'windows')

def get_vad_base(task, address):
    for vad in task.VadRoot.traverse():
        if address >= vad.Start and address < vad.End:
            return vad.Start
    return None

def get_vad_end(task, address):
    for vad in task.VadRoot.traverse():
        if address == vad.Start:
            return vad.End+1
    return None

class Malware_NameScan(common.AbstractWindowsCommand):
    """Detect Malware_Name infected process"""

    def calculate(self):
        addr_space = utils.load_as(self._config)
        if not is_valid_profile(addr_space.profile):
            debug.error("This command does not support the selected profile.")

        rules = yara.compile(sources=SIGNATURES)
        for task in tasks.pslist(addr_space):
            scanner = malfind.VadYaraScanner(task=task, rules=rules)
            for hit, address in scanner.scan(maxlen=MAX_SCAN_SIZE):
                vad_base_addr = get_vad_base(task, address)
                yield task, vad_base_addr
                break

    def render_text(self, outfd, data):
        self.table_header(outfd, [("PID", "8"),
                                  ("Image Name", "20"),
                                  ("Base Address", "[addrpad]")])
        for task, addr in data:
            self.table_row(outfd, task.UniqueProcessId, task.ImageFileName, addr)

    def render_json(self, outfd, data):
        out = {"mems": []}
        for task, addr in data:
            out["mems"].append({'pid': int(task.UniqueProcessId), "image_name": str(task.ImageFileName), 'base_address': int(addr)})
        outfd.write(json.dumps(out))
        outfd.write('\n')

class Malware_NameConfig(common.AbstractWindowsCommand):
    """Parse Malware_Name configuration"""

    def parse_config(self, task, start):
        proc_addr_space = task.get_process_address_space()
        if not is_valid_profile(addr_space.profile):
            debug.error("This command does not support the selected profile.")

        data_len = get_vad_end(task, start) - start
        data = proc_addr_space.zread(start, data_len)

        for info in MALWARE_NAME_INFO:
            offset = data.find(info['pattern'])
            if offset != -1:
                break
        else:
            return None, None

        cfg_addr = struct.unpack("=I", data[offset+info['cfg_offset']:offset+info['cfg_offset']+4])[0]
        if cfg_addr < start:
            return None, None

        cfg_offset = cfg_addr - start
        cfg_data = data[cfg_offset:cfg_offset+info['cfg_size']]
        cfg = {}
        for name, offset in info['cfg_info']:
            data = cfg_data[offset:].split('\x00')[0]
            cfg[name] = data
        return (cfg_addr, cfg)

    def calculate(self):
        addr_space = utils.load_as(self._config)
        if not is_valid_profile(addr_space.profile):
            debug.error("This command does not support the selected profile.")

        rules = yara.compile(sources=SIGNATURES)
        for task in tasks.pslist(addr_space):
            #print task, task.ImageFileName, task.UniqueProcessId
            scanner = malfind.VadYaraScanner(task=task, rules=rules)
            for hit, address in scanner.scan(maxlen=MAX_SCAN_SIZE):
                vad_base_addr = get_vad_base(task, address)
                yield task, self.parse_config(task, vad_base_addr)
                break

    def render_text(self, outfd, data):
        for task, (cfg_addr, cfg) in data:
            if cfg_addr != None:
                outfd.write(HR)
                outfd.write('\n')
                outfd.write("PID: \t{}\n".format(task.UniqueProcessId))
                outfd.write("Image Name: \t{}\n".format(task.ImageFileName))
                outfd.write("Malware_Name Config at 0x{:X}:\n".format(cfg_addr))
                for k, v in sorted(cfg.items()):
                    outfd.write("  {}: \t{}\n".format(k, v))

    def render_json(self, outfd, data):
        out = {"mems": []}
        for task, (cfg_addr, cfg) in data:
            if cfg_addr != None:
                tmp = {}
                for k, v in sorted(cfg.items()):
                    tmp[snake_case(k)] = v
                out["mems"].append({'pid': int(task.UniqueProcessId), "image_name": str(task.ImageFileName), 'malware_name': {'cfg_address': int(cfg_addr), 'cfg': tmp}})
        outfd.write(json.dumps(out))
        outfd.write('\n')
